///********************************************************************
//1. 题目来源：https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree/
//
//2. 原题
//108. 将有序数组转换为二叉搜索树
//给你一个整数数组 nums ，其中元素已经按 升序 排列，请你将其转换为一棵 高度平衡 二叉搜索树。
//
//高度平衡 二叉树是一棵满足「每个节点的左右两个子树的高度差的绝对值不超过 1 」的二叉树。
//
//
//
//示例 1：
//输入：nums = [-10,-3,0,5,9]
//输出：[0,-3,9,-10,null,5]
//解释：[0,-10,5,null,-3,null,9] 也将被视为正确答案：
//
//示例 2：
//输入：nums = [1,3]
//输出：[3,1]
//解释：[1,3] 和 [3,1] 都是高度平衡二叉搜索树。
//
//3. 归类：dfs
//
//4. 解题要点:找到vector中间点，左边作为左子树，右边作为右子树，然后dfs
//终止条件为vector.size（）=0;
//
//**********************************************************************/
//
///*************************头文件*****************************/
//#include <iostream>
//#include <vector>
//#include <set>
//#include <algorithm>
//#include <stack>
//#include <map>
//using namespace std;
//
///*************************实现函数*****************************/
//
////  Definition for a binary tree node.
//  struct TreeNode {
//      int val;
//      TreeNode *left;
//      TreeNode *right;
//      TreeNode() : val(0), left(nullptr), right(nullptr) {}
//      TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
//      TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
//  };
// 
//class Solution {
//public:
//	TreeNode* sortedArrayToBST(vector<int>& nums) {
//		TreeNode* root = dfs(nums, 0, nums.size() - 1);
//		return root;
//
//	}
//
//	TreeNode* dfs(vector<int>& nums, int left_index, int right_index) {
//		if (left_index > right_index) return nullptr;
//		int mid = (left_index + right_index) / 2;
//		TreeNode* curr = new TreeNode(nums[mid]);
//		curr->left=dfs(nums, left_index, mid-1);
//		curr->right=dfs(nums, mid + 1, right_index);
//		return curr;
//	}
//};
//
///*************************main函数 输入输出*****************************/
//int main() {
//	vector<int> in = { -10,-3,0,5,9 };
//	Solution s1;
//	s1.sortedArrayToBST(in);
//
//	system("pause");
//	return 0;
//}